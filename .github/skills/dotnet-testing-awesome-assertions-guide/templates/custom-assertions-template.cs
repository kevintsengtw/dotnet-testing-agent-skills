using AwesomeAssertions;
using AwesomeAssertions.Primitives;
using System.Linq.Expressions;

namespace YourProject.Tests.CustomAssertions;

/// <summary>
/// 自訂 Assertions 擴展範本
/// 用於建立領域特定的斷言方法，提升測試可讀性與可維護性
/// </summary>
/// 
#region 領域特定 Assertions - 電商範例

/// <summary>
/// 電商領域的自訂 Assertions
/// </summary>
public static class ECommerceAssertions
{
    /// <summary>
    /// 驗證產品是否有效
    /// </summary>
    public static AndConstraint<ObjectAssertions> BeValidProduct(
        this ObjectAssertions assertions,
        string because = "",
        params object[] becauseArgs)
    {
        var product = assertions.Subject as Product;

        product.Should().NotBeNull("Expected a Product object, but found {0}", assertions.Subject?.GetType());

        product!.Id.Should().BeGreaterThan(0, "Product ID must be greater than 0");
        product.Name.Should().NotBeNullOrEmpty("Product name cannot be null or empty");
        product.Price.Should().BeGreaterThan(0, "Product price must be greater than 0");

        return new AndConstraint<ObjectAssertions>(assertions);
    }

    /// <summary>
    /// 驗證訂單是否有效
    /// </summary>
    public static AndConstraint<ObjectAssertions> BeValidOrder(
        this ObjectAssertions assertions,
        string because = "",
        params object[] becauseArgs)
    {
        var order = assertions.Subject as Order;

        order.Should().NotBeNull("Expected an Order object");

        order!.Id.Should().BeGreaterThan(0, "Order ID must be greater than 0");
        order.Items.Should().NotBeNullOrEmpty("Order must contain at least one item");
        order.TotalAmount.Should().BeGreaterThan(0, "Order total amount must be greater than 0");
        order.Items.Should().AllSatisfy(item =>
        {
            item.Quantity.Should().BeGreaterThan(0, "Item quantity must be positive");
            item.Price.Should().BeGreaterThan(0, "Item price must be positive");
        });

        return new AndConstraint<ObjectAssertions>(assertions);
    }

    /// <summary>
    /// 驗證購物車狀態
    /// </summary>
    public static AndConstraint<ObjectAssertions> BeValidCart(
        this ObjectAssertions assertions)
    {
        var cart = assertions.Subject as ShoppingCart;

        cart.Should().NotBeNull();
        cart!.Items.Should().NotBeNull("Cart items should not be null");
        cart.TotalItems.Should().Be(cart.Items.Count, "Total items count should match actual items");
        cart.TotalAmount.Should().Be(
            cart.Items.Sum(i => i.Price * i.Quantity),
            "Total amount should equal sum of all items");

        return new AndConstraint<ObjectAssertions>(assertions);
    }
}

#endregion

#region 智慧排除擴展

/// <summary>
/// 智慧欄位排除擴展
/// 自動排除常見的自動生成欄位與審計欄位
/// </summary>
public static class SmartExclusionExtensions
{
    /// <summary>
    /// 排除自動生成的欄位（ID、時間戳記、版本號等）
    /// </summary>
    public static EquivalencyOptions<T> ExcludingAutoGeneratedFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.Path.EndsWith("Id") &&
                            ctx.SelectedMemberInfo.Name.StartsWith("Generated"))
            .Excluding(ctx => ctx.Path.EndsWith("At"))
            .Excluding(ctx => ctx.Path.EndsWith("Time"))
            .Excluding(ctx => ctx.Path.Contains("Version"))
            .Excluding(ctx => ctx.Path.Contains("RowVersion"))
            .Excluding(ctx => ctx.Path.Contains("Timestamp"));
    }

    /// <summary>
    /// 排除審計欄位（CreatedBy、CreatedAt、ModifiedBy、ModifiedAt 等）
    /// </summary>
    public static EquivalencyOptions<T> ExcludingAuditFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.Path.Contains("CreatedBy"))
            .Excluding(ctx => ctx.Path.Contains("CreatedAt"))
            .Excluding(ctx => ctx.Path.Contains("ModifiedBy"))
            .Excluding(ctx => ctx.Path.Contains("ModifiedAt"))
            .Excluding(ctx => ctx.Path.Contains("LastModified"))
            .Excluding(ctx => ctx.Path.Contains("LastUpdated"));
    }

    /// <summary>
    /// 排除所有時間相關欄位
    /// </summary>
    public static EquivalencyOptions<T> ExcludingAllTimeFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTime))
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTimeOffset))
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTime?))
            .Excluding(ctx => ctx.RuntimeType == typeof(DateTimeOffset?));
    }

    /// <summary>
    /// 組合：排除所有常見的自動欄位
    /// </summary>
    public static EquivalencyOptions<T> ExcludingCommonAutoFields<T>(
        this EquivalencyOptions<T> options)
    {
        return options
            .ExcludingAutoGeneratedFields()
            .ExcludingAuditFields();
    }
}

#endregion

#region 效能優化 Assertions

/// <summary>
/// 效能優化的 Assertions 擴展
/// 用於處理大量資料的情境
/// </summary>
public static class PerformanceOptimizedAssertions
{
    /// <summary>
    /// 大量資料集的快速驗證
    /// 使用抽樣策略而非全量比對
    /// </summary>
    public static void AssertLargeDataSet<T>(
        IEnumerable<T> actual,
        IEnumerable<T> expected,
        int sampleSize = 1000)
    {
        var actualList = actual.ToList();
        var expectedList = expected.ToList();

        // 快速數量檢查
        actualList.Should().HaveCount(expectedList.Count);

        // 抽樣驗證
        var totalCount = actualList.Count;
        var actualSampleSize = Math.Min(sampleSize, totalCount);

        var sampleIndices = Enumerable.Range(0, actualSampleSize)
            .Select(i => Random.Shared.Next(totalCount))
            .Distinct()
            .ToList();

        foreach (var index in sampleIndices)
        {
            actualList[index].Should().BeEquivalentTo(expectedList[index]);
        }
    }

    /// <summary>
    /// 只驗證關鍵屬性，提升效能
    /// </summary>
    public static void AssertKeyPropertiesOnly<T>(
        T actual,
        T expected,
        params Expression<Func<T, object>>[] keySelectors)
    {
        foreach (var selector in keySelectors)
        {
            var actualValue = selector.Compile()(actual);
            var expectedValue = selector.Compile()(expected);

            actualValue.Should().Be(expectedValue,
                $"Key property {selector} should match");
        }
    }
}

#endregion

#region 條件式 Assertions

/// <summary>
/// 條件式 Assertions 建構器
/// 根據條件執行不同的驗證邏輯
/// </summary>
public static class ConditionalAssertions
{
    public static ConditionalAssertion<T> When<T>(this T subject, bool condition)
    {
        return new ConditionalAssertion<T>(subject, condition);
    }
}

public class ConditionalAssertion<T>
{
    private readonly T _subject;
    private readonly bool _condition;

    public ConditionalAssertion(T subject, bool condition)
    {
        _subject = subject;
        _condition = condition;
    }

    public AndConstraint<ObjectAssertions> Then(Action<T> assertion)
    {
        if (_condition)
        {
            assertion(_subject);
        }

        return new AndConstraint<ObjectAssertions>(_subject.Should());
    }
}

#endregion

#region 使用範例

/// <summary>
/// 自訂 Assertions 使用範例
/// </summary>
public class CustomAssertionsUsageExamples
{
    [Fact]
    public void UseCase_領域特定Assertions()
    {
        var product = new Product
        {
            Id = 1,
            Name = "Laptop",
            Price = 999.99m
        };

        // 使用自訂的領域特定 Assertion
        product.Should().BeValidProduct();
    }

    [Fact]
    public void UseCase_智慧排除()
    {
        var user = new User
        {
            Id = 1,
            Name = "John",
            Email = "john@example.com",
            CreatedAt = DateTime.Now,
            UpdatedAt = DateTime.Now,
            RowVersion = new byte[] { 1, 2, 3 }
        };

        var retrieved = new User
        {
            Id = 1,
            Name = "John",
            Email = "john@example.com",
            CreatedAt = DateTime.Now.AddDays(-1),  // 不同
            UpdatedAt = DateTime.Now.AddHours(-2),  // 不同
            RowVersion = new byte[] { 4, 5, 6 }     // 不同
        };

        // 使用智慧排除擴展
        retrieved.Should().BeEquivalentTo(user, options => options
            .ExcludingCommonAutoFields()
        );
    }

    [Fact]
    public void UseCase_效能優化()
    {
        var largeDataset = Enumerable.Range(1, 100000)
            .Select(i => new DataRecord { Id = i, Value = $"Record_{i}" })
            .ToList();

        var processed = largeDataset.Select(r => r).ToList();

        // 使用效能優化的驗證策略
        PerformanceOptimizedAssertions.AssertLargeDataSet(
            processed,
            largeDataset,
            sampleSize: 1000
        );
    }

    [Fact]
    public void UseCase_條件式Assertions()
    {
        bool isAdmin = true;
        var user = new User
        {
            Id = 1,
            Name = "Admin",
            Email = "admin@example.com"
        };

        // 根據條件執行不同的驗證
        user.When(isAdmin)
            .Then(u => u.Name.Should().StartWith("Admin"));

        user.When(!isAdmin)
            .Then(u => u.Name.Should().NotStartWith("Admin"));
    }
}

#endregion

#region 測試用的模型類別

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public int Stock { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class Order
{
    public int Id { get; set; }
    public string CustomerName { get; set; } = string.Empty;
    public List<OrderItem> Items { get; set; } = new();
    public decimal TotalAmount { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class OrderItem
{
    public int ProductId { get; set; }
    public string ProductName { get; set; } = string.Empty;
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

public class ShoppingCart
{
    public int Id { get; set; }
    public List<OrderItem> Items { get; set; } = new();
    public int TotalItems => Items.Count;
    public decimal TotalAmount => Items.Sum(i => i.Price * i.Quantity);
}

public class User
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public byte[]? RowVersion { get; set; }
}

public class DataRecord
{
    public int Id { get; set; }
    public string Value { get; set; } = string.Empty;
}

#endregion
